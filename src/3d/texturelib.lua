-- texture lib

local json = require("json")
local iolib = require("iolib")

local lib = {}

local function getImageDimensions( ... )
	local image = display.newImage( unpack( arg ) )
	local dims = { width=image.width, height=image.height }
	image = display.remove( image )
	return dims
end

local face, top, bottom, right, left, back = 1, 2, 3, 4, 5, 6
local spock = {
	--optional parameters; used for scaled content support
	sheetContentWidth = 1024,
	sheetContentHeight = 809,
	
	-- array of four point tables representing each frame (required)
	frames =
	{
		{ name="face", 565,254 , 565,400 , 773,400 , 773,254 }, -- face
		{ name="top", 565,47 , 565,254 , 773,254 , 773,47 },   -- top
		{ name="bottom", 565,400 , 565,607 , 773,607 , 773,400 }, -- bottom
		{ name="right", 773,254 , 773,400 , 981,400 , 981,254 }, -- right
		{ name="left", 357,254 , 357,400 , 565,400 , 565,254 }, -- left
		{ name="back", 149,254 , 149,400 , 357,400 , 357,254 }, -- back
	},
	aligns = {
		-- {}, {}: facet to transform, facet to align with
		-- facet: index of facet
		-- a, b: point indices to align
		{ { facet=top, a=2, b=3 },		{ facet=face, a=1, b=4 } },
		{ { facet=bottom, a=1, b=4 },	{ facet=face, a=2, b=3 } },
		{ { facet=right, a=1, b=2 },	{ facet=face, a=4, b=3 } },
		{ { facet=left, a=4, b=3 },		{ facet=face, a=1, b=2 } },
		{ { facet=back, a=4, b=3 },		{ facet=left, a=1, b=2 } },
	},
	joins = {
		-- {}, {}: data for each facet involved in a join
		-- facet: index of the facet being joined
		-- a, b: indices of the axis points to rotate around (nil to avoid rotating)
		-- join: index of the point on this facet to join
		-- ext: list of facets to transform cumulatively with this facet transform
		{ { facet=top, a=2, b=3, join=4, ext={} },		{ facet=right, a=2, b=1, join=4, ext={} } },
		{ { facet=bottom, a=4, b=1, join=2, ext={} },	{ facet=left, a=4, b=3, join=2, ext={back} } },
--		{ { facet=left, a=4, b=3, join=1, ext={back} },	{ facet=top, a=nil, b=nil, join=1, ext={} } },
		{ { facet=back, a=3, b=4, join=1, ext={} },		{ facet=right, a=nil, b=nil, join=4, ext={} } },
	}
}
lib.spock = spock

local function getFrameByName( self, name )
	for i=1, #self.frames do
		if (self.frames[i].name == name) then
			return self.frames[i]
		end
	end
end
spock.getFrameByName = getFrameByName

--[[
	Returns the outer most x and y values of the point pairs passed in.
	Parameters:
		x,y,x,y,x,y,x,y: Bounding x,y values of the polygon corners.
]]--
local function getSides( ... )
	local left, right = 10000000000000, -10000000000000
	local top, bottom = 10000000000000, -10000000000000
	
	for i=1, #arg-1, 2 do
		local x, y = arg[i], arg[i+1]
		if (x < left) then left=x elseif (x > right) then right=x end
		if (y < top) then top=y elseif (y > bottom) then bottom=y end
	end
	
	return left, right, top, bottom
end

--[[
	Rounds up the input values to the next, nearest multiple of 4.
]]--
local function roundUpTo4( width, height )
	width, height = width + 10, height + 10
	return width + (4-width%4), height + (4-height%4)
end

--[[
	Shifts the path up and left by half the width and height.
	Fairly dumb, this assumes the path is generated by graphics.newOutline() and all values are > 0.
]]--
local function reCentrePath( path, width, height )
	width, height = width/2, height/2
	
	local t = {}
	
	for i=1, #path-1, 2 do
		t[i] = path[i] - width
		t[i+1] = path[i+1] - height
	end
	
	return t
end

--[[
	Removes the directory name prefix and inserts the append name before the file extension.
]]--
local function appendToRootFilename( filename, append )
	local name, ext = string.extractFilenameAndExt( filename )
	return name..append.."."..ext
end

--[[
	Generates a polygon offset shrunken mask of the input image.
	
	Parameters:
		filename: Filename of the image to shrink a generate a mask from.
		baseDir: Base directory - default is: system.ResourcesDirectory
	
	Return:
		filename: Filename of the generated, shrunken mask image in the system.DocumentsDirectory.
]]--
local function generateMask( filename, baseDir )
	baseDir = baseDir or system.ResourcesDirectory
	
	local maskname = appendToRootFilename( filename, "_mask" )
	local shrinkname = appendToRootFilename( filename, "_shrink" )
	
	local group = display.newGroup()
	group.x, group.y = display.actualCenterX, display.actualCenterY
	
	local image = display.newImage( group, filename, baseDir )
	
	local outline = graphics.newOutline( 1, filename, baseDir )
	outline = reCentrePath( outline, image.width, image.height )
	
	local width, height = image.width + 10, image.height + 10
	width, height = width + (4-width%4), height + (4-height%4)
	
	display.newRect( group, 0, 0, width, height ).fill = {0,0,0}
	
	display.newPolygon( group, 0, 0, outline )
	
	local line = display.newLine( group, unpack( outline ) )
	line.strokeWidth = 4
	line.stroke = {0,0,0}
	
	group.x, group.y = 0, 0
	local container = display.newContainer( width, height )
	container:insert( group )
	container.x, container.y = display.actualCenterX, display.actualCenterY
	
	display.save( container, { filename=maskname, baseDir=system.DocumentsDirectory, captureOffscreenArea=false, backgroundColor={0,0,0} } )
	
	local dupl = display.newImage( filename, baseDir )
	dupl.x, dupl.y = display.actualCenterX, display.actualCenterY
	
	dupl:setMask( graphics.newMask( maskname, system.DocumentsDirectory ) )
	
	display.save( dupl, { filename=shrinkname, baseDir=system.DocumentsDirectory, captureOffscreenArea=false, backgroundColor={0,0,0,0} } )
	
	group = display.remove( group )
	image = display.remove( image )
	container = display.remove( container )
	dupl = display.remove( dupl )
	
	return shrinkname, maskname
end
lib.generateMask = generateMask

local function test_generateMask()
	local a, b
	
	a, b = generateMask( "3d/monkeyswing.png" )
	print(a,b)
	local shrink = display.newImage( a, system.DocumentsDirectory )
	shrink.x, shrink.y = display.actualContentWidth*.33, display.actualContentHeight*.15
	
	a, b = generateMask( "3d/corona.png" )
	print(a,b)
	local shrink = display.newImage( a, system.DocumentsDirectory )
	shrink.x, shrink.y = display.actualContentWidth*.33, display.actualContentHeight*.5
end
--test_generateMask()

--[[
	Creates a saved image of a rect which would be filled by the parameters passed in.
	The output image can then be used to fill an image and apply composite effects.
	
	Parameters:
		filename, baseDir: The file and base directory of the image to cut up.
		x, y: The fill.effect.x/y to use
		width,height: The dimensions of the rect to fill.
		scaleX, scaleY: The scaling values of the fill.
	
	Note:
		This is necessary because composite effects cannot have scaling applied.
]]--
local function extractTextureFragment( filename, baseDir, x, y, width, height, scaleX, scaleY )
	local name, ext = string.extractFilenameAndExt( filename )
	local fragmentname = name.."_"..x.."_"..y.."_"..width.."_"..height.."_"..scaleX.."_"..scaleY.."."..ext
	
	if (not iolib.fileExists( fragmentname, system.DocumentsDirectory )) then
		local rect = display.newRect( display.actualCenterX, display.actualCenterY, width, height )
		rect.fill = { type="image", filename=filename, baseDir=baseDir }
		rect.fill.x, rect.fill.y = x, y
		rect.fill.scaleX, rect.fill.scaleY = scaleX, scaleY
		
		display.save( rect, { filename=fragmentname, baseDir=system.DocumentsDirectory, captureOffscreenArea=false, backgroundColor={0,0,0} } )
		
		rect = display.remove( rect )
	end
	
	return fragmentname, system.DocumentsDirectory
end
lib.extractTextureFragment = extractTextureFragment

--[[
	Shows the image sheet on screen with control points highlighted.
]]--
local function showTextureSheetControls( filename, baseDir, options )
	baseDir = baseDir or system.ResourcesDirectory
	local group = display.newGroup()
	
	local image = display.newImage( group, filename, baseDir )
	image.anchorX, image.anchorY = 0, 0
	
	group.xScale, group.yScale = display.actualContentWidth/image.width, display.actualContentWidth/image.width
	group.x, group.y = display.actualCenterX-(group.width*group.xScale)/2, display.actualCenterY-(group.width*group.yScale)/2
	
	local text = display.newText{ x=display.actualCenterX, y=50, text=image.width.." x "..image.height }
	
	local back = display.newRect( group, image.width/2, image.height/2, image.width, image.height )
	back:toBack()
	
	for i=1, #options.frames do
		local r, g, b = math.random(100,255)/255, math.random(100,255)/255, math.random(100,255)/255
		local frame = options.frames[i]
		
		for f=1, #frame-1, 2 do
			display.newCircle( group, frame[f], frame[f+1], 5 ).fill = {.5,.5,1}
		end
	end
	
	for i=1, #options.joins do
		for j=1, #options.joins[i] do
			local join = options.joins[i][j]
			
			local frameA, frameB = getFrameByName(options,join[1]), getFrameByName(options,join[3])
			local cornerIndexA, cornerIndexB = join[2], join[4]
			
			local a = display.newCircle( group, frameA[cornerIndexA*2-1], frameA[cornerIndexA*2], 20 )
			a.fill = {1,0,0,0}; a.stroke = {1,0,0}; a.strokeWidth = 2
			local b = display.newCircle( group, frameB[cornerIndexB*2-1], frameB[cornerIndexB*2], 10 )
			b.fill = {1,0,0,0}; b.stroke = {0,0,1}; b.strokeWidth = 2
		end
	end
end
--showTextureSheetControls( "3d/cubes/spock.png", nil, spock )

--[[
	Returns a display group of path objects filled with the extracted frames of the texture sheet.
]]--
local function generateTextureSheet( filename, baseDir, options, displaytype, excludeDisplayObjects, isAlwaysVisible )
	baseDir = baseDir or system.ResourcesDirectory
	local group = display.newGroup()
	group.x = -200
	
	local image = getImageDimensions( filename, baseDir )
	
	local facets = {
		isDirtyRender = true,
		group = nil,--group,
		filename = filename,
		name = "texturetest",
		isDirtyRender = true,
		normalfilename = normalfilename,
		flat = nil, -- flattened points for the whole shape (includes z)
		transformed = nil, -- points for the whole shape
		matrix = math.newXRotationMatrix(0), -- will be this object's transform matrix
		location = {x=0,y=0,z=0,rx=0,ry=0,rz=0}, -- location in space
	}
	
	local function addVerticesToFacet( vertices, facet )
		local function centreVertices( frame )
			local left, right, top, bottom = getSides( unpack( frame ) )
			local x, y = (left+right)/2, (top+bottom)/2
			local verts = {}
			
			for i=1, #frame-1, 2 do
				verts[#verts+1] = frame[i] - x
				verts[#verts+1] = frame[i+1] - y
			end
			
			return verts
		end
		vertices = centreVertices( vertices )
		
		for v=1, #vertices-1, 2 do
			facet[#facet+1] = { vertices[v], vertices[v+1], 0, 1 }
		end
	end
	
	local function getVertices( frame )
		local function convertFacetVerticesToMeshVertices( frame )
			local vertex = {}
			
			vertex[1], vertex[2] = frame[7], frame[8]
			
			for i=1, 6 do
				vertex[#vertex+1] = frame[i]
			end
			
			return vertex
		end
		
		if (displaytype == nil or displaytype == "rect") then
			return frame
		else
			return convertFacetVerticesToMeshVertices( frame )
		end
	end
	
	local x, y = display.actualCenterX, 100
	
	for i=1, #options.frames do
		local left, right, top, bottom = getSides( unpack( options.frames[i] ) )
		local r, g, b = math.random(100,255)/255, math.random(100,255)/255, math.random(100,255)/255
		
		local vertices = getVertices( options.frames[i] )
		
		local img, fill
		if (displaytype == nil or displaytype == "rect") then
			img = display.newPathRect( group, (left+right)/2, (top+bottom)/2, right-left, bottom-top )
			img.name = options.frames[i].name
			fill = {
				filename =	filename,
				baseDir =	baseDir,
				x =			(img.x-image.width/2)/image.width,
				y =			(img.y-image.height/2)/image.height,
				scaleX =	image.width/img.width,
				scaleY =	image.height/img.height,
				rotation =	0,
			}
		elseif (displaytype == "mesh") then
			img = display.newPathMesh{
				parent = group,
				x = (left+right)/2,
				y = (top+bottom)/2,
				mode = "fan",
				vertices = vertices
			}
			img.name = options.frames[i].name
			fill={
				filename =	filename,
				baseDir =	baseDir,
				x =			(img.x-image.width/2)/image.width,
				y =			(img.y-image.height/2)/image.height,
				scaleX =	image.width/img.width,
				scaleY =	image.height/img.height,
				rotation =	0,
			}
		end
		
		facets[#facets+1] = {
			flat={},
			transformed={},
			image=img,
			rect=nil,
			mesh=nil,
			fill=fill,
			isAlwaysVisible=isAlwaysVisible,
		}
		
		img.fill = { type="image", filename=filename, baseDir=baseDir }
		img.fill.x, img.fill.y = (img.x-image.width/2)/image.width, (img.y-image.height/2)/image.height
		img.fill.scaleX, img.fill.scaleY = image.width/img.width, image.height/img.height
		
		if (displaytype == nil or displaytype == "rect") then
			facets[i].rect = {
				width=(left+right)/2,
				height=(top+bottom)/2,
			}
		elseif (displaytype == "mesh") then
			facets[i].mesh = {}
		end
		
		addVerticesToFacet( options.frames[i], facets[i] )
	end
	
	if (excludeDisplayObjects) then
		for i=1, #facets do
			facets[i].image = display.remove( facets[i].image )
		end
	end
	
	print(json.prettify(json.encode(facets)))
	
	facets.joins, facets.aligns = options.joins, options.aligns
	
	return facets
end
--generateTextureSheet( "3d/cubes/spock.png", nil, spock, "mesh", false, true )
lib.generateTextureSheet = generateTextureSheet

local function testFoldEquation()
	local Ax, Ay, Az = 0, 0, 0  -- base corner
	local Bx, By, Bz = 1, 10, 0 -- top corner
	local Cx, Cy, Cz = 10, 1, 0 -- right corner

	local _Bx = Bx
	local _By = Cy
	local _Bz = By-Cy
	local _Cx = Bx
	local _Cy = Cy
	local _Cz = Cx-Bx

	print(_Bz,_Cz)
	print("B: ",math.vector2d3dLength{ _Bx, _By, _Bz })
	print("C: ",math.vector2d3dLength{ _Cx, _Cy, _Cz })
end
--testFoldEquation()

return lib
